
snippet hello "hello" b
/* Filename: main.c
 * Description: <TODO>
 * Last modified: humble 2021-01-28 09:22:42
 */
#include <stdio.h>
#include <stdlib.h>

static void usage(void)
{
#define USAGE "Usage:\n\
	Version 1.0.0\n"
	printf(USAGE);
}

int main(int argc, char **argv)
{
	if(argc != 1){ fprintf(stderr, "argc !=1"); usage(); exit(1); }

	printf("hello world\n");
	usage();
	return 0;
}
endsnippet

snippet l.h "l.h" b
#ifndef __L_H__
#define __L_H__
#include <stdio.h>
#include <syslog.h>

#define l_e(fmt, arg...) do {\
	fprintf(stderr, "%s:%d:%s " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## arg);\
	syslog(LOG_ERR, "%s:%d:%s " fmt, __FILE__, __LINE__, __FUNCTION__, ## arg);\
} while (0)

#define l_w(fmt, arg...) do {\
	printf("%s:%d:%s " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## arg);\
	syslog(LOG_WARNING, "%s:%d:%s " fmt, __FILE__, __LINE__, __FUNCTION__, ## arg);\
} while (0)

#define l_n(fmt, arg...) do {\
	printf("%s:%d:%s " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## arg);\
	syslog(LOG_NOTICE, "%s:%d:%s " fmt, __FILE__, __LINE__, __FUNCTION__, ## arg);\
} while (0)

#define l_i(fmt, arg...) do {\
	printf("%s:%d:%s " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## arg);\
	syslog(LOG_INFO, "%s:%d:%s " fmt, __FILE__, __LINE__, __FUNCTION__, ## arg);\
} while (0)

#define l_d(fmt, arg...) do {\
	printf("%s:%d:%s " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## arg);\
	syslog(LOG_DEBUG, "%s:%d:%s " fmt, __FILE__, __LINE__, __FUNCTION__, ## arg);\
} while (0)

#endif /* ifndef __L_H__ */
endsnippet

snippet sigterm_handler "sigterm_handler" b
static void sigterm_handler(int signal) { l_i("stoping"); event_base_loopbreak(dev.base); }

${0}
endsnippet


snippet proginit "program init" b
log_open(PROG);
if (!uci_check_bool(PROG ".enable")) { l_d(PROG " has not enabled"); return 0; }
if (daemon(0, 0) < 0) { l_e(PROG " daemon() failed"); exit(1); }
if (daemon_check_running("/var/run/" PROG ".pid")) { l_e(PROG " was already run"); exit(1); }
l_i(PROG " runing succeeds");
signal(SIGTERM, sigterm_handler);
if (0 >= ${1:conf_init}()) { exit(1); }

${0}
endsnippet


snippet mosqfun "mosqfun" b
static bool_t connected = true;
static uint32_t pub_cnt = 0;

static void mosq_cb_on_connect(struct mosquitto *mosq, void *obj, int result)
{
	l_d("MQTT connected");
	connected = true;
	//should we subscribe some topics??
}

static void mosq_cb_on_disconnect(struct mosquitto *mosq, void *obj, int rc)
{
	int rec_rc;
	connected = false;

	rec_rc = mosquitto_reconnect_async(mosq);
	l_w("MQTT reconnecting in 10s");
	sleep(10);
	if (MOSQ_ERR_SUCCESS != rec_rc) {
		l_d("MQTT reconnect error:%s", mosquitto_strerror(rec_rc));
		connected = false;
	}

	//Should we stop reconnect_async() if the Broker close the MQTT link?
	//mosquitto_loop_stop(mosq, false);
	//mosquitto_destroy(mosq);
	//mosquitto_lib_cleanup();
}

static void mosq_cb_on_sub(struct mosquitto *mosq, void *obj, int mid, int qos_count, const int *granted_qos)
{
	l_d("topic connected");
}

static void mosq_cb_on_log(struct mosquitto *mosq, void *obj, int leve_log, const char *string) { l_d("%s", string); }

static void mosq_cb_on_pub(struct mosquitto *mosq, void *obj, int mid)
{
	l_d("MQTT Message published. count:%d", ++pub_cnt);
	usi_printf(PROG ".count", "%d", pub_cnt);
}

static int mosq_pub(struct mosquitto *mosq, const char *topic, int32_t payloadlen,
		const char *payload, int qos)
{
	int32_t rc;
	const char *error_string = NULL;

	if (NULL == mosq || NULL == topic || NULL == payload || payloadlen <= 0) {
		l_e("Param invalid");
		return ERROR;
	}

	l_d("'%s' '%s'", topic, payload);
	rc = mosquitto_publish(mosq, NULL, topic, payloadlen, payload, qos, true);
	if (MOSQ_ERR_SUCCESS != rc) {
		error_string = mosquitto_strerror(rc);
		l_e("Pub failed:%s", error_string);
		return ERROR;
	}

	return OK;
}

static void mosq_rcv(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)
{
	char *recv_str = (char *)message->payload;
	l_d("%s get %s %s", mosqclientid, (char *)message->topic, recv_str);
	return ;
}

${0}
endsnippet


snippet mqtt.h "mqtt.h" b
#ifndef __MQTT_H__
#define __MQTT_H__
#include <mosquitto.h>
#include <event.h>
#include <event2/util.h>
#include <mosquitto.h>

typedef enum {
	MQTT_INIT = 0,
	MQTT_CONNECTING,
	MQTT_DISCONNECTED,
	MQTT_RECONNECTING,
	MQTT_RUNINGTASK,
	MQTT_END
} mqtt_state_t;

typedef struct {
	const char *addr;
	int32_t port;
	const char *clientid;
	const char *usr;
	const char *pwd;
	int keepalive;

	/* status */
	struct mosquitto *mosq;
	mqtt_state_t state;
	int8_t is_connected;
	int32_t pub_cnt;

	struct event fsmev;
	struct timeval fsmevinterval;

	//task list
	//const char *subtopic;
	const char *pubtopic;
	int8_t msgqos;
	const char *southsn;
	const char *linkkey;
	int32_t linktimeout;
	int32_t lasttime;
	//const char *payloadfmt;
}mqtt_t;

extern void mosq_cb_on_connect(struct mosquitto *mosq, void *obj, int result);
extern void mosq_cb_on_disconnect(struct mosquitto *mosq, void *obj, int rc);
extern void mosq_cb_on_sub(struct mosquitto *mosq, void *obj, int mid, int qos_count, const int *granted_qos);
extern void mosq_cb_on_unsub(struct mosquitto *mosq, void *obj, int mid);
extern void mosq_cb_on_log(struct mosquitto *mosq, void *obj, int leve_log, const char *string);
extern void mosq_cb_on_pub(struct mosquitto *mosq, void *obj, int mid);
extern int mosq_pub(struct mosquitto *mosq, const char *topic, int32_t payloadlen, const char *payload, int qos);
extern void mosq_rcv(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message);
extern void mqtt_fsm_cb(evutil_socket_t fd, short event, void *user_data);

#endif //__MQTT_H__
endsnippet


snippet mqtt.c "mqtt.c" b
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <mosquitto.h>
#include <json.h>

#include "librouter.h"
#include "rlib_uci.h"
#include "dev.h"
#include "l.h"


void mosq_cb_on_connect(struct mosquitto *mosq, void *obj, int result)
{
    rdev_t *devptr = (rdev_t *)obj;
    devptr->mqtt.is_connected = 1;
    devptr->mqtt.state = MQTT_RUNINGTASK;
    l_d("MQTT connected");
    usi_printf(PROG ".status", "%s connected", devptr->mqtt.addr);
    //should we subscribe some topics??
}

void mosq_cb_on_disconnect(struct mosquitto *mosq, void *obj, int rc)
{
    rdev_t *devptr = (rdev_t *)obj;
    devptr->mqtt.is_connected = 0;
    devptr->mqtt.state = MQTT_RECONNECTING;
    l_w("MQTT on_disconnect");
    usi_printf(PROG ".status", "%s disconnected", devptr->mqtt.addr);
}

void mosq_cb_on_sub(struct mosquitto *mosq, void *obj, int mid, int qos_count, const int *granted_qos)
{
    l_d("topic subed");
    rdev_t *devptr = (rdev_t *)obj;
#if 0
    if(devptr->mqtt.state == MQTT_SUB_TOPOGET){ devptr->mqtt.state = MQTT_PUB_TOPOGET; }
    else if(devptr->mqtt.state == MQTT_SUB_SUBDEVICEBATCHLOGIN){
        devptr->mqtt.state = MQTT_PUB_SUBDEVICEBATCHLOGIN; }
#endif
}

void mosq_cb_on_unsub(struct mosquitto *mosq, void *obj, int mid)
{
    l_d("topic unsubed");
    //rdev_t *devptr = (rdev_t *)obj;
}

void mosq_cb_on_log(struct mosquitto *mosq, void *obj, int leve_log, const char *string) { l_d("%s", string); }

void mosq_cb_on_pub(struct mosquitto *mosq, void *obj, int mid)
{
    rdev_t *devptr = (rdev_t *)obj;
    l_d("MQTT Message published. count:%d, mid:%d", devptr->mqtt.pub_cnt, mid);
}

int mosq_pub(struct mosquitto *mosq, const char *topic, int32_t payloadlen, const char *payload, int qos)
{
    int32_t rc;
    const char *error_string = NULL;

    if (NULL == mosq || NULL == topic || NULL == payload || payloadlen <= 0) {
        l_e("Param invalid");
        return -1;
    }

    l_i("%s %s %s qos%d", dev.mqtt.clientid, topic, payload, qos);
    rc = mosquitto_publish(mosq, NULL, topic, payloadlen, payload, qos, true);
    if (MOSQ_ERR_SUCCESS != rc) {
        error_string = mosquitto_strerror(rc);
        l_e("Pub failed:%s", error_string);
        return -1;
    }

    return 0;
}

void mosq_rcv(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)
{
    char buf[4096] = {0};
    rdev_t *devptr = (rdev_t *)obj;
    l_i("%s %s %s", devptr->mqtt.clientid, (char *)message->topic, (char *)message->payload);
    return ;
}


void mqtt_fsm_cb(evutil_socket_t fd, short event, void *user_data)
{
    int rc;
    int mid = 0;
    char buf[4096] = {0};
    int32_t now = 0;
    //struct timeval tv;
    rdev_t *devptr = (rdev_t *)user_data;
    switch (devptr->mqtt.state) {
        case MQTT_INIT:
        case MQTT_CONNECTING:
            rc = mosquitto_connect_async(devptr->mqtt.mosq, devptr->mqtt.addr, devptr->mqtt.port, devptr->mqtt.keepalive);
            if (MOSQ_ERR_SUCCESS == rc) {  l_d("mosquitto_connect_async() rc %d", rc); }
            else { l_w("mosquitto_connect_async() failed:rc %d, %s, reconnect after 10s", rc, mosquitto_strerror(rc)); }
            devptr->mqtt.state = MQTT_RECONNECTING; //connect once,then reconnect always if needed
            devptr->mqtt.fsmevinterval.tv_sec = 8;
            devptr->mqtt.fsmevinterval.tv_usec = 0;
            break;

        case MQTT_DISCONNECTED:
        case MQTT_RECONNECTING:
            rc = mosquitto_reconnect_async(devptr->mqtt.mosq);
            if (MOSQ_ERR_SUCCESS == rc) { l_d("mosquitto_reconnect_async() rc %d", rc); }
            else { l_w("mosquitto_reconnect_async() failed:rc %d, %s, reconnect after 10s", rc, mosquitto_strerror(rc)); }
            devptr->mqtt.fsmevinterval.tv_sec = 3;
            devptr->mqtt.fsmevinterval.tv_usec = 0;
            break;

        case MQTT_RUNINGTASK:
            //foreach the tasklist:pub data to broker
            /*
            gettimeofday(&tv,NULL);
            sprintf(buf, devptr->mqtt.payloadfmt, devptr->mqtt.pub_cnt, devptr->mqtt.pub_cnt % 2, ((int64_t)tv.tv_sec - 10)*1000UL + tv.tv_usec / 1000);
            devptr->mqtt.pub_cnt++;
            mosq_pub(devptr->mqtt.mosq, devptr->mqtt.pubtopic, strlen(buf), buf, 2);
            devptr->mqtt.fsmevinterval.tv_sec = 60;
            devptr->mqtt.fsmevinterval.tv_usec = 0;
            */
            now = time(NULL);
            if(now - devptr->mqtt.lasttime > devptr->mqtt.linktimeout){
                sprintf(buf,"{\"SN\":\"%s\",\"DT\":%d,\"MG\":[[\"%s\",\"0\"]]}",
                        devptr->mqtt.southsn, now, devptr->mqtt.linkkey); ;
                mosq_pub(devptr->mqtt.mosq, devptr->mqtt.pubtopic, strlen(buf), buf, devptr->mqtt.msgqos);
                devptr->mqtt.lasttime = now;
            }
            l_d("MQTT runing");
            break;

        default:
            l_w("Unkown MQTT_STATE:%d", devptr->mqtt.state);
            break;
    }

    event_add(&dev.mqtt.fsmev, &dev.mqtt.fsmevinterval); //redo
}
endsnippet


snippet mosqinit "mosqinit" b
mosquitto_lib_init();
struct mosquitto *${1:mosq} = mosquitto_new(${2:conf}.${3:serial_number}, ${4:true}, ${5:agr});
if (NULL == $1) { l_e("mosquitto_new() failed"); mosquitto_lib_cleanup(); exit(1); }

mosquitto_username_pw_set($1, $2.${6:usr}, $2.${7:pwd});
mosquitto_connect_callback_set($1, mosq_cb_on_connect);
mosquitto_disconnect_callback_set($1, mosq_cb_on_disconnect);
mosquitto_subscribe_callback_set($1, mosq_cb_on_sub);
mosquitto_publish_callback_set($1, mosq_cb_on_pub);
mosquitto_log_callback_set($1, mosq_cb_on_log);
mosquitto_message_callback_set($1, mosq_rcv);
mosquitto_will_set($1, "Message/LastWill", strlen("hello"), "hello", 1, false);

int rc = mosquitto_connect_async($1, $2.${8:addr}, $2.${9:port}, $2.${10:keepalive});
if (MOSQ_ERR_SUCCESS != rc) { l_w("%s", mosquitto_strerror(rc)); }
else { /* mqtt_publish($1, $2.topic, strlen($2.payload), $2.payload, 1); */ }

l_d("start to loop");
mosquitto_loop_start($1);

${0}

mosquitto_loop_stop(mosq, false);
mosquitto_destroy(mosq);
mosquitto_lib_cleanup();
endsnippet


snippet setitimer "setitimer()" b
static volatile int loop = 0;

signal(SIGALRM, alrm_handler);

struct itimerval itv = {
	.it_value = { .tv_sec = ${1:conf.interval}, .tv_usec = 0 },//firstly
	.it_interval = { .tv_sec = ${2:conf.interval}, .tv_usec = 0 } //reset to
};
if (0 > setitimer(ITIMER_REAL, &itv, NULL)) { l_e("setitimer() failed"); exit(1); }

while (1) {
	while (0 == loop) { pause(); }
	loop = 0;
	if (connected) {
		${0:do sth}
	}
}
endsnippet


snippet ugs "uci_get(string)" b
conf.${1:element} = (char *)uci_get(PROG ".$1");
if (NULL == conf.$1) { l_e("get " PROG ".$1 failed"); return ERROR; }
l_d("get " PROG ".$1 \"%s\"", conf.$1);

${0}
endsnippet


snippet ugi "uci_get(int)" b
tmpptr = (char *)uci_get(PROG ".${1:element}");
if (NULL == tmpptr) { l_e("get " PROG ".$1 failed"); return ERROR; }
conf.$1 = atoi(tmpptr);
l_d("get " PROG ".$1 %d", conf.$1);

${0}
endsnippet

snippet set "set()" b
endsnippet
